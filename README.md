# TypeScript-Notes
## TypeScript Introduction 
TypeScript is typed JavaScript. TypeScript adds types to JavaScript to help you speed up the development by catching errors before you even run the JavaScript code.  
TypeScript is an open-source programming language that builds on top of JavaScript. It works on any web browser, any OS, and any environment that JavaScript runs.  
1. TypeScript is a superset of JavaScript.  
2. TypeScript builds on top of JavaScript. First, you write the TypeScript code. Then, you compile the TypeScript code into plain JavaScript code using a TypeScript compiler.  
3. Once you have the plain JavaScript code, you can deploy it to any environment that JavaScript runs.  
4. TypeScript files use the .ts extension rather than the .js extension of JavaScript files.  

![image](https://github.com/user-attachments/assets/1fd8641a-d8fc-4393-b304-c6f2c7632402)  

5. TypeScript uses the JavaScript syntaxes and adds additional syntaxes for supporting Types.
6. If you have a JavaScript program without any syntax errors, it is a TypeScript program. This means that all JavaScript programs are TypeScript programs. This is very helpful if you migrate an existing JavaScript codebase to TypeScript.
   
![image](https://github.com/user-attachments/assets/6d6fac26-07cf-4acc-91b4-35713196cd98)  


## Why TypeScript
The main goals of TypeScript are:
1. Introduce optional types to JavaScript.
2. Implement planned features of future JavaScript, a.k.a. ECMAScript Next or ES Next to the current JavaScript.

### TypeScript improves your productivity while helping avoid bugs
Types increase productivity by helping you avoid many mistakes. By using types, you can catch bugs at the compile time instead of having them occur at runtime.<br /><br />
For example, the following function adds two numbers x and y:<br />
`
function add(x, y) {
   return x + y;
}
`<br /><br />
If you get the values from HTML input elements and pass them into the function, you may get an unexpected result:<br />
`let result = add(input1.value, input2.value);
console.log(result); // result of concatenating strings`  

For example, if users entered **10** and **20**, the **add()** function would return **1020**, instead of **30**.  

The reason is that **input1.value** and **input2.value** are **strings**, not **numbers**. When you use the operator **+** to add two strings, it concatenates them into a single string.  

When you use TypeScript to specify the type for the parameters like this explicitly:  
`
function add(x: number, y: number) {
   return x + y;
}
`  

In this function, we added the number types to the parameters. The function **add()** will accept only numbers, not any other values.

When you invoke the function as follows:<br />
`
let result = add(input1.value, input2.value);
`<br /><br />
The TypeScript compiler will issue an error if you compile the **TypeScript** code into **JavaScript**. Hence, you can prevent the error from happening at runtime.  

### TypeScript brings the future JavaScript to today
TypeScript supports the upcoming features planned in the ES Next for the current JavaScript engines. It means you can use the new JavaScript features before web browsers (or other environments) fully support them. <br />

### Summary
1. TypeScript is a superset of JavaScript.
2. TypeScript adds type to the JavaScript and helps you avoid potential bugs that occur at runtime.
3. TypeScript also implements the future features of JavaScript.

## Setup
1. Install Node.js
2. Install typescript: `npm install -g typescript` <br/>
Check typescript compiler version: `tsc --v` <br/>
3. If you want to run TypeScript code directly on Node.js without precompiling, you can use the tsx module: `npm install -g tsx` <br/>

### Summary
1. A TypeScript compiler compiles the TypeScript into JavaScript.
2. Use the tsc command to compile a TypeScript file to a JavaScript file.
3. Use the tsx module to run TypeScript directly on Node.js without precompiling it to JavaScript.

## TypeScript “Hello, World!”
1. Create a new directory to store the code, e.g., helloworld.
2. Create a new TypeScript file called app.ts. The extension of a TypeScript file is .ts
3. Type the following source code in the app.ts file:<br/>
`let message: string = 'Hello, World!';
console.log(message);`
4. Type the following command on the Terminal to compile the app.ts file:<br/>
`tsc app.ts`
5. If everything is fine, you’ll see a new file called `app.js` is generated by the TypeScript compiler.
6. To run the app.js file in Node.js, you use the following command:<br/>
`node app.js`
7. If you installed the tsx module, you can use just one command to run the TypeScript file directly on Node.js without precompiling it to JavaScript:<br/>
`tsx app.ts`

## TypeScript Benefits
1. TypeScript adds a type system to help you avoid many problems with dynamic types in JavaScript.
2. TypeScript implements the future features of JavaScript a.k.a ES Next so you can use them today.

## Dynamic Types in JavaScript
JavaScript is dynamically typed. Unlike statically typed languages such as Java or C#, values have types instead of variables.<br/><br/>
`let box;
box = "hello";
box = 100;`
<br/>
<br/>
The type of the box variable changes based on the value assigned to it.<br/>
To find the type of the box variable at runtime, you use the **typeof operator**<br/>
```
let box;
console.log(typeof(box)); // undefined

box = "Hello";
console.log(typeof(box)); // string

box = 100;
console.log(typeof(box)); // number
```
<br/>
The first statement defines a variable box without assigning a value in this example. Its type is undefined.<br/>
Then, we assign the literal string "Hello" to box variable and show its type. The type of the box variable changes to string.<br/>
Finally, we assign 100 to the box variable. This time, the type of the box variable changes to number.<br/>
As you can see, as soon as the value is assigned, the type of the variable changes.<br/>
And you don’t need to explicitly tell JavaScript the type. JavaScript will automatically infer the type from the value.<br/>
Dynamic types offer flexibility. However, they also lead to problems.<br/>

### Problems with dynamic types
Suppose you have a function that returns a product object based on an id:<br/>
```
function getProduct(id){
  return {
    id: id,
    name: `Awesome Gadget ${id}`,
    price: 99.5
  }
}
```
<br/>
The following uses the getProduct() function to retrieve the product with id 1 and show its data: <br/> 

```
const product = getProduct(1);
console.log(`The product ${product.Name} costs $${product.price}`);
```

<br/>
Output:<br/>
The product undefined costs $99.5 <br/>

It isn’t what we expected.<br/>

The issue with this code is that the product object doesn’t have the Name property. It has the name property with the first letter n in lowercase.
<br/>
However, you can only know it until you run the script. <br/>
Referencing a property that doesn’t exist on the object is a common issue when working in JavaScript. <br/>
The following example defines a new function that outputs the product information to the console: <br/>
```
const showProduct = (name, price)  => {
  console.log(`The product ${name} costs $${price}.`);
};
```
<br/>
The following uses the getProduct() and showProduct() functions: <br/>

```
const product = getProduct(1);
showProduct(product.price, product.name);
```

<br/>
The product 99.5 costs $Awesome Gadget 1 <br/>
This time we pass the arguments in the wrong order to the showProduct() function. This is another common problem that you often have when working with JavaScript.<br/>
This is why TypeScript comes into play.<br/>

### How Typescript solves problems of dynamic types
To fix the problem of referencing a property that doesn’t exist on an object, you do the following steps:<br/>

First, define the “shape” of the product object using an interface.<br/>
```
interface Product{
    id: number,
    name: string,
    price: number
};
```
<br/>

Second, explicitly use the Product type as the return type of the getProduct() function:<br/>
```
function getProduct(id) : Product{
  return {
    id: id,
    name: `Awesome Gadget ${id}`,
    price: 99.5
  }
}
```
<br/>
When you reference a property that doesn’t exist, the code editor will inform you immediately: <br/>

```
const product = getProduct(1);
console.log(`The product ${product.Name} costs $${product.price}`);
```

<br/>
The code editor highlighted the following error on the Name property<br/><br/>
![image](https://github.com/user-attachments/assets/8f6fde4d-af51-401c-b62c-ddca6869d4da)

<br/><br/>
And when you hover the mouse cursor over the error, you’ll see a hint that helps you to solve the issue:<br/><br/>
![image](https://github.com/user-attachments/assets/e5f1e923-b471-408a-9968-c692d3d0b02d)

<br/><br/>
To solve the problem of passing the arguments in the wrong order, you explicitly assign types to function parameters: <br/>

```
const showProduct = (name: string, price:number)  => {
  console.log(`The product ${name} costs $${price}.`);
};
```

<br/>
And when you pass the arguments of the wrong types to the showProduct() function, you’ll receive an error: <br/><br/>

```
const product = getProduct(1);
showProduct(product.price, product.name);
```

<br/>

### Summary
1. JavaScript is dynamically typed, providing flexibility but also leading to many problems.
2. TypeScript adds an optional type system to JavaScript to solve these problems.

## TypeScript Types
### What is a type in TypeScript

In TypeScript, a type is a convenient way to refer to different properties and functions that a value has. <br/>
A value is anything you can assign to a variable e.g., a number, a string, an array, an object, and a function <br/>
For example, see the following value: `'Hello'` <br/>
When you look at this value, you can say it is a string. This value has properties and methods that a string has. <br/>

For example, the 'Hello' value has a property called length that returns the number of characters: <br/>
`console.log('Hello'.length); // 5`

It also has many methods like match(), indexOf(), and toLocaleUpperCase(). For example: <br/>
`console.log('Hello'.toLocaleUpperCase()); // HELLO` <br />

When you look at the value 'Hello' and describe it by listing the properties and methods, it would be inconvenient. <br />

A shorter way to refer to a value is to assign it a type. In this example, you say 'Hello' is a string. Then, you know that you can use the properties and methods of a string for the value 'Hello' <br />

In conclusion, in TypeScript:

1. a type is a label that describes the different properties and methods that a value has
2. every value has a type.

### Types in TypeScript
TypeScript inherits the built-in types from JavaScript. TypeScript types are categorized into:

1. Primitive types.
2. Object types.

### Primitive types
![image](https://github.com/user-attachments/assets/dae2fcbb-2560-4fae-aa56-32dc6a3b284e)  

### Object Types
Object types are functions, arrays, classes, etc.

### Purposes of types in TypeScript
There are two main purposes of types in TypeScript:

1. First, types are used by the TypeScript compiler to analyze your code for errors.
2. Second, types allow you to understand what values are associated with variables.

### Summary
1. In TypeScript, every value is associated with a type.
2. A type is a label that describes the properties and methods that a value has.
3. TypeScript compiler uses types to analyze your code for hunting bugs and errors.

## Understanding Type Annotations in TypeScript
TypeScript uses type annotations to specify explicit types for identifiers such as variables, functions, objects, etc. <br/>

TypeScript uses the syntax : type after an identifier as the type annotation, which type can be any valid type. <br/>

Once an identifier is annotated with a type, it can be used as that type only. If the identifier is used as a different type, the TypeScript compiler will issue an error. <br/>

### Type annotations in variables and constants
The following syntax shows how to specify type annotations for variables and constants: <br/>
```
let variableName: type;
let variableName: type = value;
const constantName: type = value;
```
<br/> 
In this syntax, the type annotation comes after the variable or constant name and is preceded by a colon (:). <br/> 

The following example uses number annotation for a variable: <br/> 
`
let counter: number;
`
<br/> 
After this, you can only assign a number to the counter variable: <br/> 
`
counter = 1;
`
<br/> 
If you assign a string to the counter variable, you’ll get an error: <br/> 

```
let counter: number;
counter = 'Hello'; // compile error
```

<br/> 
Error: <br/> 

`
Type '"Hello"' is not assignable to type 'number'.
`

<br/> 
You can both use a type annotation for a variable and initialize it in a single statement like this: <br/> 

`let counter: number = 1;`

<br/> 
The following shows other examples of primitive type annotations: <br/> 

```
let name: string = 'John';
let age: number = 25;
let active: boolean = true;
```

<br/> 

## Type annotation examples
### Arrays

To annotate an array type you use a specific type followed by a square bracket : type[] : <br/>

```
let arrayName: type[];
```

 <br/>
For example, the following declares an array of strings: <br/>

```
let names: string[] = ['John', 'Jane', 'Peter', 'David', 'Mary'];
```

 <br/>

 ### Objects
To specify a type for an object, you use the object type annotation. For example: <br/>

```
let person: {
  name: string;
  age: number;
};

person = {
  name: 'John',
  age: 25,
}; // valid

```

<br/>

In this example, the person object only accepts an object with two properties: name with the string type and age with the number type.

### Function arguments & return types
The following shows a function annotation with parameter type annotation and return type annotation: <br />
```
let greeting : (name: string) => string;
```

<br/>

In this example, you can assign any function that accepts a string and returns a string to the greeting variable: <br />

```
greeting = function (name: string) {
    return `Hi ${name}`;
};
```

<br />


The following causes an error because the function that is assigned to the greeting variable doesn’t match its function type. <br />

```
greeting = function () {
    console.log('Hello');
};
```

Error: <br />
```
Type '() => void' is not assignable to type '(name: string) => string'. Type 'void' is not assignable to type 'string'.
```

### Summary
Use type annotations with the syntax : [type] to explicitly specify a type for a variable, function, function return value, etc.

## TypeScript Type Inference
Type inference describes where and how TypeScript infers types when you don’t explicitly annotate them. <br/>

### Basic type inference
When you declare a variable, you can use a type annotation to explicitly specify a type for it. For example: <br />

```
let counter: number;
```

<br/>
However, if you initialize the counter variable with a number, TypeScript will infer the type of the counter to be number. For example: <br/>

```
let counter = 0;
```

<br/>
It is equivalent to the following statement: <br/>

```
let counter: number = 0;
```

<br />
Likewise, when you assign a function parameter a value, TypeScript infers the type of the parameter to the type of the default value. For example: <br/>

```
function setCounter(max=100) {
    // ...
}
```

In this example, TypeScript infers the type of the max parameter to be number. <br />

```
function setCounter(max=100) {
    // ...
}
```

<br />

Similarly, TypeScript infers the following return type of the increment() function as number: <br />

```
function increment(counter: number) {
    return counter++;
}
```

<br/>
It is the same as: <br/>

```
function increment(counter: number) : number {
    return counter++;
}
```

<br/>

### The best common type algorithm

Consider the following assignment: <br />

```
let items = [1, 2, 3, null];
````

<br />
To infer the type of items variable, TypeScript needs to consider the type of each element in the array.
<br />
It uses the best common type algorithm to analyze each candidate type and select the type that is compatible with all other candidates.
<br />
In this case, TypeScript selects the number or null array type (number | null) []) as the best common type. Note that the | means the OR operator in types.
<br />
If you add a string to the items array, TypeScript will infer the type for the items as an array of numbers and strings: (number | string)[]
<br />

```
let items = [1, 2, 3, 'Cheese'];
```

<br />

### Contextual typing
TypeScript uses the locations of variables to infer their types. This mechanism is known as contextual typing. For example: <br />

```
document.addEventListener('click', function (event) {
    console.log(event.button); 
});
```

<br />
In this example, TypeScript knows that the event parameter is an instance of MouseEvent because of the click event.
<br />
However, when you change the click event to the scroll the event, TypeScript will issue an error:
<br />

```
document.addEventListener('scroll', function (event) {
    console.log(event.button); // compile error
});
```

<br />

Error:
<br />

```
Property 'button' does not exist on type 'Event'.(2339)
```

<br />

TypeScript knows that the event in this case, is an instance of UIEvent, not a MouseEvent. And UIEvent does not have the button property, therefore, TypeScript throws an error.
<br />
You will find contextual typing in many cases such as arguments to function calls, type assertions, members of objects and array literals, return statements, and right-hand sides of assignments.
<br />

### Type inference vs. Type annotations
The following shows the difference between type inference and type annotations: <br />

Type inference	- TypeScript guesses the type	 <br />

Type annotations - You explicitly tell TypeScript the type <br />

### When do you use type inference and type annotations?
<br />
In practice, you should always use the type inference as much as possible. You use the type annotation in the following cases:
<br />
1. When you declare a variable and assign it a value later.
2. When you want a variable that can’t be inferred.
3. When a function returns the any type, you need to clarify the value.

### Summary
1. Type inference occurs when you initialize variables, set parameter default values, and determine function return types.
2. TypeScript uses the best common type algorithm to select the best candidate types that are compatible with all variables.
3. TypeScript also uses contextual typing to infer types of variables based on the locations of the variables.

## TypeScript Number
All numbers in TypeScript are either **floating-point values or big integers**. The floating-point numbers have the type **number** while the big integers get the type **bigint**.
<br/>
### The number type
The following shows how to declare a variable that holds a floating-point value: <br/>
`let price: number;`
<br />
Alternatively, you can initialize the price variable to a number: <br />
`let price = 9.95;`
<br />

### Big Integers
The big integers represent the whole numbers larger than 2 power 53 – 1. A Big integer literal has the **n** character at the end of an integer literal like this: <br />
`let big: bigint = 9007199254740991n;`
<br/>

```
JavaScript has the Number type (with the letter N in uppercase) that refers to the non-primitive boxed object. You should not use this Number type as much as possible in TypeScript.
```

<br/>

### Summary
All numbers in TypeScript are either **floating-point values** that get the **number type** or **big integers** that get the **bigint type**.
Avoid using the Number type as much as possible.

## TypeScript String
Like JavaScript, TypeScript uses double quotes (") or single quotes (') to surround string literals: <br/>

```
let firstName: string = 'John';
let title: string = "Web Developer";
```

<br/>
TypeScript also supports template strings that use the backtick (`) to surround characters. <br/>

```
let firstName: string = `John`;
let title: string = `Web Developer`;
let profile: string = `I'm ${firstName}. 
I'm a ${title}`;

console.log(profile);
```

<br/>

Output <br/>

```
I'm John. 
I'm a Web Developer.
```

<br />

### Summary
1. In TypeScript, all strings get the string type. 
2. Like JavaScript, TypeScript uses double quotes ("), single quotes ('), and backtick (`) to surround string literals.


## TypeScript Boolean
The TypeScript boolean type has two values: true and false. The boolean type is one of the primitive types in TypeScript. <br/>

```
let pending: boolean;
pending = true;
// after a while
// ..
pending = false;
```

<br/>

### Boolean operator
To manipulate boolean values, you use the boolean operators. TypeScript supports common boolean operators: <br/>

```
&&	   Logical AND operator
||	   Logical OR operator
!	   Logical NOT operator
```

<br/>

```
// NOT operator
const pending: boolean = true;
const notPending = !pending; // false
console.log(result); // false

const hasError: boolean = false;
const completed: boolean = true;

// AND operator
let result = completed && hasError; 
console.log(result); // false

// OR operator
result = completed || hasError; 
console.log(result); // true
```

<br/>

### Type annotations for boolean

```
let completed = true;
```

<br/>
Is same as:
<br/>

```
let completed: boolean = true;
```

<br/>
JavaScript has the Boolean type that refers to the non-primitive boxed object. The Boolean type has the letter B in uppercase, which is different from the boolean type. <br/>

It’s a good practice to avoid using the Boolean type. <br/>

### Summary
1. TypeScript boolean type has two values true and false.
2. Use the boolean keyword to declare boolean variables.
3. Do not use Boolean type unless you have a good reason to do so.

## TypeScript object Type

The TypeScript object type represents all values that are not in primitive types. <br/>

The following are primitive types in TypeScript: <br/>
 
1. number
2. bigint
3. string
4. boolean
5. null
6. undefined
7. symbol

<br/>

```
let employee: object;

employee = {
    firstName: 'John',
    lastName: 'Doe',
    age: 25,
    jobTitle: 'Web Developer'
};

console.log(employee);
```

<br/>
If you reassign a primitive value to the employee object, you’ll get an error : <br/>

```
employee = "Jane";
```

<br/>

```
Error:
error TS2322: Type '"Jane"' is not assignable to type 'object'.
```

<br/>
To explicitly specify properties of the employee object, you first use the following syntax to declare the employee object:
<br/>

```
let employee: {
    firstName: string;
    lastName: string;
    age: number;
    jobTitle: string;
};
```

<br/>
And then assign the employee object to a literal object with the described properties:
<br/>

```
employee = {
    firstName: 'John',
    lastName: 'Doe',
    age: 25,
    jobTitle: 'Web Developer'
};
```

<br/>

Or you can combine both syntaxes in the same statement like this:
<br/>

```
let employee: {
    firstName: string;
    lastName: string;
    age: number;
    jobTitle: string;
} = {
    firstName: 'John',
    lastName: 'Doe',
    age: 25,
    jobTitle: 'Web Developer'
};
```

<br/>

### object vs. Object
TypeScript has another type called Object with the letter O in uppercase. It’s important to understand the differences between them. <br/>
 
The object type represents all non-primitive values while the Object type describes the functionality of all objects. <br/>

For example, the Object type has the toString() and valueOf() methods that can be accessible by any object. <br/>

### Summary
1. The TypeScript object type represents any value that is not a primitive value.
2. The Object type, however, describes functionality that is available on all objects.
3. The empty type {} refers to an object that has no property on its own.

## TypeScript Array Type
A TypeScript array is an ordered list of data. To declare an array that holds values of a specific type, you use the following syntax: <br/>

```
let arrayName: type[];
```

<br/>
For example, the following declares an array of strings: <br/>

```
let skills: string[] = [];
```

<br/>

The following declares a variable and assigns an array of strings to it:
<br/>

```
let skills = ['Problem Sovling','Software Design','Programming'];
```

<br/>

In this example, TypeScript infers the skills array as an array of strings. It is equivalent to the following: <br/>

```
let skills: string[];
skills = ['Problem Sovling','Software Design','Programming'];
```

<br/>

After you define an array of a specific type, TypeScript will prevent you from adding incompatible values. For example, the following will cause an error:
<br/>

```
skills.push(100);
```

<br/>

Because we’re trying to add a number to the string array.
<br/>
Error:
<br/>

```
Argument of type 'number' is not assignable to parameter of type 'string'.
```

<br/>

### Storing values of mixed types
The following illustrates how to define an array that holds both strings and numbers: <br/>

```
let scores = ['Programming', 5, 'Software Design', 4];
```


<br/>
In this case, TypeScript infers the scores array as an array of **string | number**. It’s equivalent to the following: <br/>

```
let scores : (string | number)[];
scores = ['Programming', 5, 'Software Design', 4];
```

<br/>

### Summary
1. In TypeScript, an array is an ordered list of values.
2. Use the let **arr: type[]** syntax to declare an array of a specific type. Adding a value of a different type to the array will result in an error.
3. An array can store values of mixed types. Use the **arr: (type1 | type2) []** syntax to declare an array of values with mixed types (type1, and type2)


## TypeScript Tuple Type
A tuple works like an array with some additional considerations:

1. The number of elements in the tuple is fixed.
2. The types of elements are known, and need not be the same.

For example, you can use a tuple to represent a value as a pair of a string and a number:
<br/>

```
let skill: [string, number];
skill = ['Programming', 5];
```

<br/>

The order of values in a tuple is important. If you change the order of values of the skill tuple to [5, "Programming"], you’ll get an error. <br/>

For this reason, it’s a good practice to use tuples with data that are related to each other in a specific order. <br/>

For example, you can use a tuple to define an RGB color that always comes in a three-number pattern: <br/>

(r,g,b) <br />
For example: <br />

```
let color: [number, number, number] = [255, 0, 0];
```

<br/>

### Optional Tuple Elements
Since TypeScript 3.0, a tuple can have optional elements specified using the question mark (?) postfix. <br/>

For example, you can define an RGBA tuple with the optional alpha channel value: <br/>

```
let bgColor, headerColor: [number, number, number, number?];
bgColor = [0, 255, 255, 0.5];
headerColor = [0, 255, 255];
```

<br/>


### Summary
1. A tuple is an array with a fixed number of elements whose types are known.


## TypeScript Enum
### What is an enum
An enum is a group of named constant values. Enum stands for enumerated type.

To define an enum, you follow these steps:

1. First, use the enum keyword followed by the name of the enum.
2. Then, define constant values for the enum.
   
The following shows the syntax for defining an enum: <br/>
`enum name {constant1, constant2, ...};`
<br/>

In this syntax, the constant1, constant2, etc., are also known as the members of the enum. <br/>

### Example

```
enum Month {
    Jan,
    Feb,
    Mar,
    Apr,
    May,
    Jun,
    Jul,
    Aug,
    Sep,
    Oct,
    Nov,
    Dec
};
```

<br />
In this example, the enum name is Month and constant values are Jan, Feb, Mar, and so on. <br />  

The following declares a function that uses the Month enum as the type of the month parameter: <br />

```
function isItSummer(month: Month) {
  let isSummer: boolean;
  switch (month) {
    case Month.Jun:
    case Month.Jul:
    case Month.Aug:
      isSummer = true;
      break;
    default:
      isSummer = false;
      break;
  }
  return isSummer;
}
```

<br />

### How TypeScript enum works
It’s a good practice to use the constant values defined by enums in the code. <br />

However, the following example passes a number instead of an enum to the isItSummer() function. And it works. <br />

```
console.log(isItSummer(6)); // true
```

<br />
This example uses a number (6) instead of a constant defined by the Month enum. And it works. <br/>
Let’s check the generated Javascript code of the Month enum: <br/>

```
{
  '0': 'Jan', 
  '1': 'Feb', 
  '2': 'Mar', 
  '3': 'Apr', 
  '4': 'May', 
  '5': 'Jun', 
  '6': 'Jul', 
  '7': 'Aug', 
  '8': 'Sep', 
  '9': 'Oct', 
  '10': 'Nov',
  '11': 'Dec',
  Jan: 0,     
  Feb: 1,     
  Mar: 2,     
  Apr: 3,     
  May: 4,
  Jun: 5,
  Jul: 6,
  Aug: 7,
  Sep: 8,
  Oct: 9,
  Nov: 10,
  Dec: 11
}
```

<br/>
The output indicates that a TypeScript enum is an object in JavaScript. This object has named properties declared in the enum. For example, Jan is 0 and Feb is 1.

The generated object also has number keys with string values representing the named constants.

### Specifying enum members’ numbers
TypeScript defines the numeric value of an enum’s member based on the order of that member that appears in the enum definition. For example, Jan takes 0, Feb gets 1, etc. <br/>
It’s possible to explicitly specify numbers for the members of an enum like this: <br/>

```
enum Month {
    Jan = 1,
    Feb,
    Mar,
    Apr,
    May,
    Jun,
    Jul,
    Aug,
    Sep,
    Oct,
    Nov,
    Dec
};
```


<br/>
In this example, the Jan constant value takes 1 instead of 0. The Feb takes 2, and the Mar takes 3, etc.
<br/>

### When to use an enum
You should use an enum when you:

1. Have a small set of closely related fixed values.
2. And these values are known at compile time.

For example, you can use an enum for the approval status: <br/>

```
enum ApprovalStatus {
    draft,
    submitted,
    approved,
    rejected
};

const request =  {
    id: 1,
    status: ApprovalStatus.approved,
    description: 'Please approve this request'
};

if(request.status === ApprovalStatus.approved) {
    // send an email
    console.log('Send email to the Applicant...');
}
```

<br/>

### Summary
1. A TypeScript enum is a group of constant values.
2. Under the hood, an enum is a JavaScript object with named properties declared in the enum definition.
3. Do use an enum when you have a small set of fixed values that are closely related and known at compile time.

## Introduction to TypeScript any type
Sometimes, you may need to store a value in a variable. But you don’t know its type when writing the program. And the unknown value may come from a third-party API or user input. <br/>

In this case, you want to opt out of the type checking and allow the value to pass through the compile-time check. <br/>

```
let result: any;

result = 1;
console.log(result);

result = 'Hello';
console.log(result);

result = [1, 2, 3];
const total = result.reduce((a: number, b: number) => a + b, 0);
console.log(total);
```

<br/>
Let’s take another typical example: <br/>

```
// json may come from a third-party API
const json = `{"latitude": 10.11, "longitude":12.12}`;

// parse JSON to find location
const currentLocation = JSON.parse(json);
console.log(currentLocation);
```

<br/>

```
{ latitude: 10.11, longitude: 12.12 }
```

<br/>
In this example, TypeScript infers the value of the currentLocation variable as any. We assign an object returned by the JSON.parse() function the currentLocation variable. <br/>

However, when we access the non-existing property (x) of the currentLocation variable, TypeScript does not carry any checks. <br/>

This is working fine and shows an undefined value in the console: <br/>

```
console.log(currentLocation.x); // undefined
```

<br/>


The TypeScript compiler doesn’t complain or issue any errors. <br/>

The any type provides you with a way to work with the existing JavaScript codebase. It allows you to gradually opt in and opt out of type-checking during compilation. Therefore, you can use the any type for migrating a JavaScript project over to TypeScript. <br/>

### TypeScript any: implicit typing
If you declare a variable without specifying a type, TypeScript assumes that you use the any type. This feature is called type inference. TypeScript guesses the type of the variable. For example: <br/>

```
let result;
```

<br/>

### Summary
1. The TypeScript any type allows you to store a value of any type. It instructs the compiler to skip type-checking.
2. Use the any type to store a value that you don’t know its type at the compile-time or when you migrate a JavaScript project over to a TypeScript project.

## TypeScript unknown type
In TypeScript, the unknown type can hold a value that is not known upfront but requires type checking. <br/>

To declare a variable of the unknown type, you use the following syntax:  <br/>

```
let result: unknown;
```

<br/>

Like the any type, you can assign any value to a variable of the unknown type. For example: <br/>

```
let result: unknown;

result = 1;
result = 'hello';
result = false;
result = Symbol();
result = { name: 'John' };
result = [1, 2, 3];
```

<br/>

_**Unlike the any type, TypeScript checks the type before performing operations on it.**_  

For example, you cannot call a method or apply an operator on a unknown value. If you attempt to do so, the TypeScript compiler will issue an error: <br/>  

```
let result: unknown;
result = [1,2,3];

const total = result.reduce((a: number, b:number ) => a + b, 0);
console.log(total);
```

<br/>

In this example, the result variable has the type of unknown. We assign an array the result value, but its type is still unknown. Therefore, we cannot call the reduce() method of an array on it.  <br/>

To call the reduce() method on the result variable, you need to use the type assertion to explicitly tell the TypeScript compiler that the type of the result is an array. For example: <br/>

 
```
let result: unknown;
result = [1, 2, 3];

const total = (result as number[]).reduce((a: number, b: number) => a + b, 0);
console.log(total); // 6
```

<br/>

In this example, we explicitly tell the TypeScript compiler that the type of the result is an array of numbers (result as number[]).

Therefore, we can call the reduce() method on the result array without any issues. <br/><br/>

![image](https://github.com/user-attachments/assets/c9fb4ca4-b904-4f28-983a-487628f4d94d)


<br /><br/>

### Uses: Handling external data
When receiving data from an external API, you can use the unknown type to enforce validation before processing it.  
The following example shows how to use the fetch method to call an API from the `https://jsonplaceholder.typicode.com/posts` endpoint: <br />


```
const fetchData = async (url: string): Promise<unknown> => {
    const response = await fetch(url);
    return await response.json();
};

const showPosts = async () => {
    const url = 'https://jsonplaceholder.typicode.com/posts';
    try {
        const posts = await fetchData(url); // unknown type

        (posts as { userId: number; id: number; title: string; body:                string }[]).map((post) => console.log(post.title));

    } catch (err) {
        console.log(err);
    }
};

showPosts();
```

<br/>

First, define a function fetchData that calls API from a URL and returns JSON data. Since the shape of the returned data is not known, the function returns a Promise<unknown> value: <br/>

```
const fetchData = async (url: string): Promise<unknown> => {
    const response = await fetch(url);
    return await response.json();
};
```

<br/>

Second, define the showPosts() function that uses the fetchData() function to call an API from the endpoint `https://jsonplaceholder.typicode.com/posts:` <br/>

```
const showPosts = async () => {
    const url = 'https://jsonplaceholder.typicode.com/posts';
    try {
        const posts = await fetchData(url); // unknown type
        (
            posts as { userId: number; id: number; title: string; body: string }[]
        ).map((post) => console.log(post.title));
    } catch (err) {
        console.log(err);
    }
};
```

<br/>

In this example, the posts variable has a type of unknown.

Before accessing its title property, we use type assertion to instruct the TypeScript compiler to treat it as an array of post objects: <br/>

```
posts as { userId: number; id: number; title: string; body: string }[]
```

<br/>

Third, call the showPosts() function: <br/>

`showPosts();`

<br/>

### Summary
1. The unknown type is like any type but more restrictive.
2. Use the unknown type to handle data coming from external sources and require validation before use.


## TypeScript union type
Sometimes, you will run into a function that expects a parameter that is either a number or a string. For example: <br />


```
function add(a: any, b: any) {
    if (typeof a === 'number' && typeof b === 'number') {
        return a + b;
    }
    if (typeof a === 'string' && typeof b === 'string') {
        return a.concat(b);
    }
    throw new Error('Parameters must be numbers or strings');
}
```

<br/>


In this example, the add() function will calculate the sum of its parameters if they are numbers.

If the parameters are strings, the add() function will concatenate them into a single string.

If the parameters are neither numbers nor strings, the add() function throws an error.

The problem with the parameters of the add() function is that its parameters have the any type. It means that you can call the function with arguments that are neither numbers nor strings, the TypeScript will be fine with it.

This code will be compiled successfully but cause an error at runtime: <br />

```
add(true, false);
```

<br/>

To resolve this, you can use the TypeScript union type. The union type allows you to combine multiple types into one type. <br/>

For example, the following variable is of type number or string: <br/>

```
let result: number | string;
result = 10; // OK
result = 'Hi'; // also OK
result = false; // a boolean value, not OK
```

<br/>

A union type describes a value that can be one of several types, not just two. For example `number | string | boolean` is the type of a value that can be a number, a string, or a boolean. <br/>
Back to the add() function example, you can change the types of parameters from the any to a union like this: <br/>


```
function add(a: number | string, b: number | string) {
    if (typeof a === 'number' && typeof b === 'number') {
        return a + b;
    }
    if (typeof a === 'string' && typeof b === 'string') {
        return a.concat(b);
    }
    throw new Error('Parameters must be numbers or strings');
}
```

<br />
We can specify the union type for the add function: <br/>

```
function add(a: number | string, b: number | string) :  number | string {
    if (typeof a === 'number' && typeof b === 'number') {
        return a + b;
    }
    if (typeof a === 'string' && typeof b === 'string') {
        return a.concat(b);
    }
    throw new Error('Parameters must be numbers or strings');
}
```

<br/>

### Summary
1. A TypeScript union type allows you to store a value of one or several types in a variable.

## TypeScript String Literal Types
The string literal types allow you to define a type that accepts only one specified string literal.

The following defines a string literal type that accepts a literal string 'click': <br/>
`let click: 'click';`
<br/>
The click is a string literal type that accepts only the string-literal 'click'. If you assign the literal string 'click' to the click, it will be valid: <br/>
`click = 'click'; // valid`
<br/>
However, when you assign another string literal to the click, the TypeScript compiler will issue an error. For example: <br/>
`click = 'dblclick'; // compiler error`
<br/>
`Type '"dblclick"' is not assignable to type '"click"'.` 
<br/>
The string literal type is useful to limit a possible string value that a variable can store.
The string literal types can combine nicely with the union types to define a finite set of string literal values for a variable: <br/>

```
let mouseEvent: 'click' | 'dblclick' | 'mouseup' | 'mousedown';
mouseEvent = 'click'; // valid
mouseEvent = 'dblclick'; // valid
mouseEvent = 'mouseup'; // valid
mouseEvent = 'mousedown'; // valid
mouseEvent = 'mouseover'; // compiler error
```

<br/>
If you use the string literal types in multiple places, they will be verbose.

To avoid this, you can use the type aliases. For example: <br/>

```
type MyMouseEvent = 'click' | 'dblclick' | 'mouseup' | 'mousedown';
let mouseEvent: MyMouseEvent;
mouseEvent = 'click'; // valid
mouseEvent = 'dblclick'; // valid
mouseEvent = 'mouseup'; // valid
mouseEvent = 'mousedown'; // valid
mouseEvent = 'mouseover'; // compiler error

let anotherEvent: MyMouseEvent;
```

<br />

### Summary
1. A TypeScript string literal type defines a type that accepts specified string literal.
2. Use the string literal types with union types and type aliases to define types that accept a finite set of string literals.

## TypeScript Type Aliases
In TypeScript, a type alias allows you to create a new name for an existing type. <br/>
Type aliases can be useful for:
1. Simplifying complex types.
2. Making code more readable.
3. Creating reusable types that can be used in many places in the codebase.
To define a type alias, you use the type keyword followed by the alias name and the type it represents. <br/>
`type alias = existingType;`
<br/>
The existing type can be any valid TypeScript type including primitive type, object type, union type, intersection type, and function type. <br/>


### Type alias examples
1. Primitive types:

   ```
   type Name: string;
   let firstName: Name;
   let lastName: Name;
   ```

2. Object types:

   ```
   type Person = {
     name: string;
     age: number;
   };
   
   let person: Person = {
     name: 'John',
     age: 25
   };
   ```

3. Union Types:

   ```
   type alphanumeric = string | number;
   let input: alphanumeric;
   input = 100; // valid
   input = 'Hi'; // valid
   input = false; // Compiler error
   ```

4. Intersection Types:

   ```
   type Personal = {
     name: string;
     age: number;
   };
   
   type Contact = {
     email: string;
     phone: string;
   };
   
   type Candidate = Personal & Contact;
   
   let candidate: Candidate = {
     name: "Joe",
     age: 25,
     email: "joe@example.com",
     phone: "(408)-123-4567"
   };
   ```

### Summary
1. Use type aliases to define new names for existing types.

## TypeScript never type
In TypeScript, a type is like a set of values. For example, the number type holds the numbers 1, 2, 3, etc. The string type holds the strings like 'Hi', 'Hello', etc. The null type holds a single value, which is null.

The never type is a type that holds no value. It is like an empty set.

Since a never type does not hold any value, you cannot assign a value to a variable with the never type.
`let empty: never = 'hello';` <br/>

`Type 'string' is not assignable to type 'never'` <br/>

### So why do we need the never type in the first place?
Since the never type has zero value, you can use it to denote an impossibility in the type system.

For example, you may have an intersection type that can be both a string and a number at the same time, which is impossible:

`type Alphanumeric = string & number; // never` <br/>
Therefore, the TypeScript compiler infers the type of Alphanumeric as never.

This is because string and number are mutually exclusive. In other words, a value cannot be both a string and a number simultaneously.

Typically, you use the never type to represent the return type of a function that never returns the control to the caller. For example, a function that always throws an error: <br/>


```
function raiseError(message: string): never {
    throw new Error(message);
}
```

<br/>

If you have a function that contains an indefinite loop, its return type should be never. For example: <br/>

```
function forever(): never {
  while (true) {}
}
```


In this example, the type of the return type of the forever() function is `never`. <br/>

### TypeScript never example

```
type Role = 'admin' | 'user';

const authorize = (role: Role): string => {
  switch (role) {
    case 'admin':
      return 'You can do anything';
    case 'user':
      return 'You can do something';
    default:
      // never reach here util we add a new role
      const _unreachable: never = role;
      throw new Error(`Invalid role: ${_unreachable}`);
  }
};

console.log(authorize('admin'));

```


<br/>

Step 1. Define a type Role that can be either a string 'admin' or 'user': <br/>
`type Role = 'admin' | 'user';` <br/>

Step 2. Create the authorize() function that accepts a value of the Role type and returns a string: <br/>

```
const authorize = (role: Role): string => {
  switch (role) {
    case 'admin':
      return 'You can do anything';
    case 'user':
      return 'You can do something';
    default:
      // never reach here util we add a new role
      const _unreachable: never = role;
      throw new Error(`Invalid role: ${_unreachable}`);
  }
};
```


<br />
How it works.

First, use the switch statement to return a corresponding string if the role is admin or user. <br />
Second, define a variable called _unreachable with the type never and assign the role to it. Also, throw an error in the default branch because the execution will never reach the default branch. <br />
Why do we handle the default case? <br/>
The reason is that if we add a new value to the Role type and forget to add a logic to handle the new role, TypeScript will issue an error: <br/>

`type Role = 'admin' | 'user' | 'guest';` <br/>

In this case, we add the 'guest' to the Role type.

And TypeScript issues the following error: <br />
`Type 'string' is not assignable to type 'never'.ts(2322)` <br />

This is because the value of the role in the default branch now becomes the string 'guest' and you cannot assign a string value to a variable with the type never. <br/>
To fix this, you need to create a new case branch to handle the new role:
<br />


```
const authorize = (role: Role): string => {
  switch (role) {
    case 'admin':
      return 'You can do anything';
    case 'user':
      return 'You can do something';
    case 'guest':
      return 'You can do nothing';
    default:
      // never reach here util we add a new role
      const _unreachable: never = role;
      throw new Error(`Invalid role: ${_unreachable}`);
  }
};
```


<br/>

To make it more concise, we can define a function with the return type never and use it in the default branch: <br/>

```
type Role = 'admin' | 'user' | 'guest';

const unknownRole = (role: never): never => {
  throw new Error(`Invalid role: ${role}`);
};

const authorize = (role: Role): string => {
  switch (role) {
    case 'admin':
      return 'You can do anything';
    case 'user':
      return 'You can do something';
    case 'guest':
      return 'You can do nothing';
    default:
      // never reach here util we add a new role
      return unknownRole(role);
  }
};

console.log(authorize('admin'));
```


<br/>

### Summary
1. Use the never type that holds no value, denoting an impossibility in the type system.

## TypeScript functions
TypeScript functions are the building blocks of readable, maintainable, and reusable code.

Like JavaScript, you use the function keyword to declare a function in TypeScript: <br/>


```
function name(parameter: type, parameter:type,...): returnType {
   // do something
}
```

<br/>
Unlike JavaScript, TypeScript allows you to use type annotations in parameters and return the value of a function. <br/>


```
function add(a: number, b: number): number {
    return a + b;
}
```

<br />
In this example, the add() function accepts two parameters with the number type.

When you call the add() function, the TypeScript compiler will check each argument passed to the function to ensure that they are numbers.

In the add() function example, you can only pass numbers into it, not the values of other types.

The `: number` after the parentheses indicates the return type. The add() function returns a value of the number type in this case.

When a function has a return type, the TypeScript compiler checks every return statement against the return type to ensure that the return value is compatible with it.  

If a function does not return a value, you can use the void type as the return type. The void keyword indicates that the function doesn’t return any value. For example: <br/>

```
function echo(message: string): void {
    console.log(message.toUpperCase());
}
```

<br/>

The void prevents the code inside the function from returning a value and stops the calling code from assigning the result of the function to a variable.  <br/>
When you do not annotate the return type, TypeScript will try to infer an appropriate type. <br/>

```
function add(a: number, b: number) {
    return a + b;
}
```

<br/>

In this example, the TypeScript compiler tries to infer the return type of the add() function to the number type, which is expected.

However, if a function has different branches that return different types, the TypeScript compiler may infer the union type or any type.

Therefore, it is important to add type annotations to a function as much as possible.

### Summary
1. Use type annotations for function parameters and return type to keep the calling code inline and ensure the type checking within the function body.


## TypeScript function types
A function type has two parts: parameters and return type. When declaring a function type, you need to specify both parts with the following syntax:
<br/>

`(parameter: type, parameter:type,...) => type` <br/>

The following example shows how to declare a variable that has a function type that accepts two numbers and returns a number: <br/>

`let add: (x: number, y: number) => number;` <br/>

The function type accepts two arguments: x and y with the type number.
The type of the return value is number that follows the fat arrow (=>) appeared between parameters and return type. <br/>

Once annotating a variable with a function type, you can assign the function with the same type to the variable.

TypeScript compiler will match the number of parameters with their types and the return type. <br/>

The following example shows how to assign a function to the add variable: <br/>

 
```
add = function (x: number, y: number) {
    return x + y;
};
```

Also, you can declare a variable and assign a function to a variable like this: <br/>

```
let add: (a: number, b: number) => number =
    function (x: number, y: number) {
        return x + y;
    };
```


<br/>

add is a variable. <br/>
(a: number, b: number) => number is the function type. <br/>
And the rest is the function assigned to the add variable. <br/>

If you assign other functions whose type doesn’t match the add variable, TypeScript will issue an error: <br/>


```
add = function (x: string, y: string): number {
    return x.concat(y).length;
};
```


<br/>

### Inferring function types
TypeScript compiler can figure out the function type when you have the type on one side of the equation. This form of type inference is called contextual typing. For example: <br/><br/>
![TypeScript-Function-Type-Example](https://github.com/user-attachments/assets/42a5ca99-e1c9-49db-b232-98fef00a7ab9)

<br/><br/>

In this example, the add function will take the type `(x: number, y:number) => number`.

By using the type inference, you can significantly reduce the amount of code with annotations.


### Optional Parameters
In TypeScript, the compiler checks every function call and issues an error in the following cases: <br/>

The number of arguments is different from the number of parameters specified in the function. <br/>
Or the types of arguments are not compatible with the types of function parameters. <br/>
Because the compiler thoroughly checks the passing arguments, you need to annotate optional parameters to instruct the compiler not to issue an error when you omit the arguments. <br/>

To make a function parameter optional, you use the ? after the parameter name. For example: <br/>



```
function multiply(a: number, b: number, c?: number): number {

    if (typeof c !== 'undefined') {
        return a * b * c;
    }
    return a * b;
}
```


<br/>
The optional parameters must appear after the required parameters in the parameter list. <br/>


### Summary
1. Use the parameter?: type syntax to make a parameter optional.
2. Use the expression typeof(parameter) !== 'undefined' to check if the parameter has been initialized.


## Default Parameters
```
function applyDiscount(price: number, discount: number = 0.05): number {
    return price * (1 - discount);
}

console.log(applyDiscount(100)); // 95
```


<br/>

## Rest Parameters

A rest parameter allows a function to accept zero or more arguments of the specified type. In TypeScript, the rest parameters follow these rules:

1. A function has only one rest parameter.
2. The rest parameter appear last in the parameter list.
3. The type of the rest parameter is an array type.

To declare a rest parameter, you prefix the parameter name with three dots (…) and use the array type as the type annotation: <br/>

```
function fn(...rest: type[]) {
   //...
}
```

<br/>


```
function getTotal(...numbers: number[]): number {
    let total = 0;
    numbers.forEach((num) => total += num);
    return total;
}
```


<br/>

In this example, the getTotal() calculates the total of numbers passed into it.

Since the numbers parameter is a rest parameter, you can pass one or more numbers to calculate the total: <br/>

```
console.log(getTotal()); // 0
console.log(getTotal(10, 20)); // 30
console.log(getTotal(10, 20, 30)); // 60
```

<br/>


### Rest parameters with multiple types
```
function combine(...args: (number | string)[]): [number, string] {
  let total = 0;
  let str = '';
  args.forEach((arg) => {
    if (typeof arg === 'number') {
      total += arg;
    } else if (typeof arg === 'string') {
      str += arg;
    }
  });

  return [total, str];
}

const [total, str] = combine(3, 'Happy', 2, 1, ' New Year');

console.log({ total });
console.log({ str });
```


### Summary
1. Use rest parameters to allow a function to accept a variable number of arguments with the same or different types.
2. Use ...args type[] syntax to define rest parameters with the same type.
3. Use ...args (type1 | type2 ) [] syntax to define rest parameters with different types


## TypeScript Class
In ES5, you can use a constructor function and prototype inheritance to create a “class”.

To create a Person class that has three properties ssn, first name, and last name, you use the following **constructor function**: <br/>


```
function Person(ssn, firstName, lastName) {
    this.ssn = ssn;
    this.firstName = firstName;
    this.lastName = lastName;
}
```


<br/ >

Next, you can define a prototype method to get the full name of the person by concatenating first name and last name like this: <br/>

```
Person.prototype.getFullName = function () {
    return `${this.firstName} ${this.lastName}`;
}
```

<br/>
Then, you can use the Person “class” by creating a new object:

<br/>


```
let person = new Person('171-28-0926','John','Doe');
console.log(person.getFullName());
```


<br/>

ES6 allows you to define a class, which is simply syntactic sugar for creating constructor functions and prototypal inheritance:

<br/>


```
class Person {
    ssn;
    firstName;
    lastName;

    constructor(ssn, firstName, lastName) {
        this.ssn = ssn;
        this.firstName = firstName;
        this.lastName = lastName;
    }

    getFullName() {
        return `${this.firstName} ${this.lastName}`;
    }
}
```


<br/>

Using the Person class is the same as the Person constructor function:

<br/>

```
let person = new Person('171-28-0926','John','Doe');
console.log(person.getFullName());
```

<br/>

TypeScript class adds type annotations to the properties and methods of the class. The following shows the Person class in TypeScript:

<br/>


```
class Person {
    ssn: string;
    firstName: string;
    lastName: string;

    constructor(ssn: string, firstName: string, lastName: string) {
        this.ssn = ssn;
        this.firstName = firstName;
        this.lastName = lastName;
    }

    getFullName(): string {
        return `${this.firstName} ${this.lastName}`;
    }
}
```


<br/>

### Summary
1. Use `class` keyword to define a class in TypeScript.
2. TypeScript leverages the ES6 class syntax and adds type annotations to make the class more robust.

## TypeScript Access Modifiers
Access modifiers change the visibility of the properties and methods of a class. TypeScript provides three access modifiers:

1. private
2. protected
3. public

Note that TypeScript controls the access logically during compilation time, not at runtime.

### The private modifier
The private modifier limits the visibility to the same class only. When you add the private modifier to a property or method, you can access that property or method within the same class. Any attempt to access private properties or methods outside the class will result in an error at compiled time.

Once the private property is in place, you can access the ssn property in the constructor or methods of the Person class. For example: <br />


```
class Person {
  private ssn: string;
  private firstName: string;
  private lastName: string;

  constructor(ssn: string, firstName: string, lastName: string) {
    this.ssn = ssn;
    this.firstName = firstName;
    this.lastName = lastName;
  }

  getFullName(): string {
    return `${this.firstName} ${this.lastName}`;
  }
}
```


<br/>

The following attempts to access the ssn property outside the class: <br/>


```
let person = new Person('153-07-3130', 'John', 'Doe');
console.log(person.ssn); // compile error
```

<br/>


### The public modifier
The public modifier allows class properties and methods to be accessible from all locations. If you don’t specify any access modifier for properties and methods, they will take the public modifier by default.

### The protected modifier
The protected modifier allows properties and methods of a class to be accessible within the same class and subclasses.

When a class (child class) inherits from another class (parent class), it is a subclass of the parent class.

The TypeScript compiler will issue an error if you attempt to access the protected properties or methods from anywhere else. <br/>


```
class Person {
  protected ssn: string;
  private firstName: string;
  private lastName: string;

  constructor(ssn: string, firstName: string, lastName: string) {
    this.ssn = ssn;
    this.firstName = firstName;
    this.lastName = lastName;
  }

  getFullName(): string {
    return `${this.firstName} ${this.lastName}`;
  }
}
```


<br/>
To make the code shorter, TypeScript allows you to both declare properties and initialize them in the constructor like this: <br/>


```
class Person {
  constructor(
    protected ssn: string,
    private firstName: string,
    private lastName: string
  ) {}

  getFullName(): string {
    return `${this.firstName} ${this.lastName}`;
  }
}
```


<br/>

### Summary
1. TypeScript provides three access modifiers to class properties and methods: private, protected, and public.
2. The private modifier allows access within the same class.
3. The protected modifier allows access within the same class and subclasses.
4. The public modifier allows access from any location.
Properties and methods have public access if you omit the access modifiers.

### TypeScript readonly
TypeScript provides the readonly modifier that allows you to mark the properties of a class immutable. The assignment to a readonly property can only occur in one of two places:

1. In the property declaration.
2. In the constructor of the same class.

To mark a property as immutable, you use the readonly keyword. The following shows how to declare a readonly property in the Person class: 
<br/>


```
class Person {
    readonly birthDate: Date;

    constructor(birthDate: Date) {
        this.birthDate = birthDate;
    }
}
```


<br/>

The following attempts to reassign the birthDate property that results in an error: <br/>


```
let person = new Person(new Date(1990, 12, 25));
person.birthDate = new Date(1991, 12, 25); // Compile error
```


Error:
<br/>

`Cannot assign to 'birthDate' because it is a read-only property.` <br/>

 <br/>
![image](https://github.com/user-attachments/assets/4498cc50-b6d1-4d19-844c-8541320ad633)
 <br/> <br/>

### Summary
1. Use the readonly access modifier to mark a class property as immutable.
2. A readonly property must be initialized as a part of the declaration or in the constructor of the same class.

## TypeScript Inheritance
A class can reuse the properties and methods of another class. This is called inheritance in TypeScript.

The class which inherits properties and methods is called the child class. The class whose properties and methods are inherited is known as the parent class. These names come from the nature that children inherit genes from their parents.

Inheritance allows you to reuse the functionality of an existing class without rewriting it.

JavaScript uses prototypal inheritance, not classical inheritance like Java or C#. ES6 introduces the class syntax that is simply the syntactic sugar of the prototypal inheritance. TypeScript supports inheritance like ES6.

To inherit a class, you use the extends keyword. For example the following Employee class inherits the Person class: <br />


```
class Employee extends Person {
  //...
}
```


<br/>

### Constructor in Inheritance
Because the Person class has a constructor that initializes the firstName and lastName properties, you need to initialize these properties in the constructor of the Employee class by calling its parent class’ constructor. <br/>

To call the constructor of the parent class in the constructor of the child class, you use the super() syntax. For example: <br/>  


```
class Employee extends Person {
    constructor(
        firstName: string,
        lastName: string,
        private jobTitle: string) {
        
        // call the constructor of the Person class:
        super(firstName, lastName);
    }
}
```


<br/>

The following creates an instance of the Employee class: <br/>

`let employee = new Employee('John','Doe','Front-end Developer');`


<br/>
Because the Employee class inherits properties and methods of the Person class, you can call the getFullName() and describe() methods on the employee object as follows:
<br/>

```
let employee = new Employee('John', 'Doe', 'Web Developer');

console.log(employee.getFullName());
console.log(employee.describe());
```


<br/>

### Method overriding
When you call the employee.describe() method on the employee object, the describe() method of the Person class is executed that shows the message: This is John Doe.

If you want the Employee class has its own version of the describe() method, you can define it in the Employee class like this: <br/>


```
class Employee extends Person {
    constructor(
        firstName: string,
        lastName: string,
        private jobTitle: string) {

        super(firstName, lastName);
    }

    describe(): string {
        return super.describe() + `I'm a ${this.jobTitle}.`;
    }
}
```


<br/>
In the describe() method, we called the describe() method of the parent class using the syntax `super.methodInParentClass()`.

If you call the describe() method on the employee object, the describe() method in the Employee class is invoked: <br/>

```
let employee = new Employee('John', 'Doe', 'Web Developer');
console.log(employee.describe());
```

<br/>


```
This is John Doe.I'm a Web Developer.
```


<br/>

### Summary
1. Use the extends keyword to allow a class to inherit from another class.
2. Use super() to call the constructor of the parent class in the constructor of the child class. Also, use the super.methodInParentClass() syntax to invoke the methodInParentClass() in the method of the child class.


## TypeScript Static Methods and Properties
### Static properties
Unlike an instance property, a static property is shared among all instances of a class.

To declare a static property, you use the static keyword. To access a static property, you use the className.propertyName syntax. For example:
<br/>


```
class Employee {
    static headcount: number = 0;

    constructor(
        private firstName: string,
        private lastName: string,
        private jobTitle: string) {

        Employee.headcount++;
    }
}
```


<br/>


In this example, the headcount is a static property that is initialized to zero. Its value is increased by 1 whenever a new object is created.

The following creates two Employee objects and shows the value of the headcount property. It returns two as expected.

<br />


```
let john = new Employee('John', 'Doe', 'Front-end Developer');
let jane = new Employee('Jane', 'Doe', 'Back-end Developer');

console.log(Employee.headcount); // 2
```


<br/>


### Static methods
Similar to the static property, a static method is also shared across instances of the class. To declare a static method, you use the static keyword before the method name. For example: <br/>


```
class Employee {
    private static headcount: number = 0;

    constructor(
        private firstName: string,
        private lastName: string,
        private jobTitle: string) {

        Employee.headcount++;
    }

    public static getHeadcount() {
        return Employee.headcount;
    }
}
```


<br/>

In this example:

1. First, change the access modifier of the headcount static property from public to private so that its value cannot be changed outside of the class without creating a new Employee object.
2. Second, add the getHeadcount() static method that returns the value of the headcount static property.

To call a static method, you use the className.staticMethod() syntax. For example: <br/>

```
let john = new Employee('John', 'Doe', 'Front-end Developer');
let jane = new Employee('Jane', 'Doe', 'Back-end Developer');
console.log(Employee.getHeadcount); // 2
```


<br/>

In practice, you will find a library that contains many static properties and methods like the Math object. It has PI, E, … static properties and abs(), round(), etc., static methods.


### Summary
Static properties and methods are shared by all instances of a class.
Use the static keyword before a property or a method to make it static.

## TypeScript Abstract Classes
An abstract class is typically used to define common behaviors for derived classes to extend. Unlike a regular class, an abstract class cannot be instantiated directly. <br/>

To declare an abstract class, you use the abstract keyword: <br/>

```
abstract class Employee {
    //...
}
```

<br/>
Typically, an abstract class contains one or more abstract methods.

An abstract method does not contain implementation. It only defines the signature of the method without including the method body. An abstract method must be implemented in the derived class.  

The following shows the Employee abstract class that has the getSalary() abstract method: <br />


```
abstract class Employee {
  constructor(private firstName: string, private lastName: string) {}
  abstract getSalary(): number;
  get fullName(): string {
    return `${this.firstName} ${this.lastName}`;
  }
  compensationStatement(): string {
    return `${this.fullName} makes ${this.getSalary()} a month.`;
  }
}
```


<br/>

In the Employee class:

1. The constructor declares the firstName and lastName properties.
2. The getSalary() method is an abstract method. The derived class will implement the logic based on the type of employee.
3. The getFullName() and compensationStatement() methods contain detailed implementation. Note that the compensationStatement() method calls the getSalary() method.

Because the Employee class is abstract, you cannot create a new object from it. The following statement causes an error: <br/>

```
let employee = new Employee('John','Doe');
```

 <br/>
Error: <br/>

`error TS2511: Cannot create an instance of an abstract class.`

 <br/>

 

The following FullTimeEmployee class inherits from the Employee class: <br/>



```
class FullTimeEmployee extends Employee {
    constructor(firstName: string, lastName: string, private salary: number) {
        super(firstName, lastName);
    }
    getSalary(): number {
        return this.salary;
    }
}
```


<br/>
In this FullTimeEmployee class, the salary is set in the constructor. Because the getSalary() is an abstract method of the Employee class, the FullTimeEmployee class needs to implement this method. In this example, it just returns the salary without any calculation.

<br/>

The following shows the Contractor class that also inherits from the Employee class: <br/>


```
class Contractor extends Employee {
  constructor(
    firstName: string,
    lastName: string,
    private rate: number,
    private hours: number
  ) {
    super(firstName, lastName);
  }
  getSalary(): number {
    return this.rate * this.hours;
  }
}
```


<br/>
In the Contractor class, the constructor initializes the rate and hours. The getSalary() method calculates the salary by multiplying the rate by the hours.

<br/>
The following first creates a FullTimeEmployee object and a Contractor object and then shows the compensation statements to the console: <br/>


```
let john = new FullTimeEmployee('John', 'Doe', 12000);
let jane = new Contractor('Jane', 'Doe', 100, 160);

console.log(john.compensationStatement());
console.log(jane.compensationStatement());
```


<br/>
Output:
<br/>

```
John Doe makes 12000 a month.
Jane Doe makes 16000 a month.
```

<br/>

It’s a good practice to use abstract classes when you want to share code among some related classes.

### Summary
1. Abstract classes cannot be instantiated.
2. An Abstract class has at least one abstract method.
3. To use an abstract class, you need to inherit it and provide the implementation for the abstract methods.


## TypeScript Interface
TypeScript interfaces define the contracts within your code. They also provide explicit names for type checking. <br/>
Let’s start with a simple example: <br/>


```
function getFullName(person: {
    firstName: string;
    lastName: string
}) {
    return `${person.firstName} ${person.lastName}`;
}

let person = {
    firstName: 'John',
    lastName: 'Doe'
};

console.log(getFullName(person));
```


<br/>
In this example, the TypeScript compiler checks the argument you pass into the getFullName() function. <br/>
If the argument has two properties firstName and lastName and their types are strings, then the TypeScript compiler passes the check. Otherwise, it’ll issue an error. <br/>
The type annotation of the function argument makes the code difficult to read. To address this issue, TypeScript introduces the concept of interfaces. <br/>

The following uses an interface Person that has two string properties:

<br/>


```
interface Person {
    firstName: string;
    lastName: string;
}
```


<br/>

By convention, the interface names are in the PascalCase. They use a single capitalized letter to separate words in their names. For example, Person, UserProfile, and FullName. <br/>

After defining the Person interface, you can use it as a type. For example, you can annotate the function parameter with the interface name: <br />


```
function getFullName(person: Person) {
    return `${person.firstName} ${person.lastName}`;
}

let john = {
    firstName: 'John',
    lastName: 'Doe'
};

console.log(getFullName(john));
```



<br/>
The code now is easier to read than before.
<br />
The getFullName() function will accept any object that has at least two string properties with the name firstName and lastName. <br/>

For example, the following code declares an object that has four properties:

<br/>


```
let jane = {
  firstName: 'Jane',
  middleName: 'K.',
  lastName: 'Doe',
  age: 22,
};
```


<br/>
Since the jane object has two string properties firstName and lastName, you can pass it on to the getFullName() function as follows: <br/>


```
let fullName = getFullName(jane);
console.log(fullName); // Jane Doe
```


<br/>

### Optional properties
An interface may have optional properties. To declare an optional property, you use the question mark (?) at the end of the property name in the declaration, like this: <br/>


```
interface Person {
    firstName: string;
    middleName?: string;
    lastName: string;
}
```


<br/>

In this example, the Person interface has two required properties and one optional property. <br />

And the following shows how to use the Person interface in the getFullName() function: <br/>


```
function getFullName(person: Person) {
    if (person.middleName) {
        return `${person.firstName} ${person.middleName} ${person.lastName}`;
    }
    return `${person.firstName} ${person.lastName}`;
}
```


<br/>

### Readonly properties
If properties should be modifiable only when the object is first created, you can use the readonly keyword before the name of the property: <br/>


```
interface Person {
  readonly ssn: string;
  firstName: string;
  lastName: string;
}

let person: Person;
person = {
  ssn: '171-28-0926',
  firstName: 'John',
  lastName: 'Doe',
};
```


<br/>
In this example, the ssn property cannot be changed:
<br/>


```
person.ssn = '171-28-0000';
```


<br/>
Error:
<br/>

```
error TS2540: Cannot assign to 'ssn' because it is a read-only property.
```


<br />

### Function types
In addition to describing an object with properties, interfaces allow you to represent function types. <br />
To describe a function type, you assign the interface to the function signature that contains the parameter list with types and returned types. For example: <br/>


```
interface StringFormat {
    (str: string, isUpper: boolean): string
}

let format: StringFormat;

format = function (str: string, isUpper: boolean) {
    return isUpper ? str.toLocaleUpperCase() : str.toLocaleLowerCase();
};

console.log(format('hi', true)); // HI
```


<br/>
Note that the parameter names don’t need to match the function signature. The following example is equivalent to the above example: <br />



```
let format: StringFormat;

format = function (src: string, upper: boolean) {
    return upper ? src.toLocaleUpperCase() : src.toLocaleLowerCase();
};

console.log(format('hi', true));
```



<br/>
The StringFormat interface ensures that all the callers of the function that implements it pass in the required arguments: a string and a boolean. <br/>


### Class Types
If you have worked with Java or C#, you can find that the main use of the interface is to define a contract between classes.

For example, the following Json interface can be implemented by any class: <br/>


```
interface Json {
  toJson(): string;
}

class Person implements Json {
  constructor(private firstName: string, private lastName: string) {}
  toJson(): string {
    return JSON.stringify(this);
  }
}

let person = new Person('John', 'Doe');
console.log(person.toJson()); // {"firstName":"John","lastName":"Doe"}

```


<br/>
In the Person class, we implemented the toJson() method of the Json interface.


### Summary
1. TypeScript interfaces define contracts in your code and provide explicit names for type-checking.
2. Interfaces may have optional properties or read-only properties.
3. Interfaces can be used as function types.
4. Interfaces are typically used as class types that make a contract between unrelated classes.


### Interfaces extending one interface
Suppose that you have an interface called Mailable that contains two methods called send() and queue() as follows: <br/>


```
interface Mailable {
    send(email: string): boolean
    queue(email: string): boolean
}
```


<br/>
And you have many classes that already implemented the Mailable interface.
Now, you want to add a new method to the Mailable interface that sends an email later like this: <br/>


```
later(email: string, after: number): boolean
```


<br/>


However, adding the later() method to the Mailable interface would break the current code. <br/>

To avoid this, you can create a new interface that extends the Mailable interface: <br/>


```
interface FutureMailable extends Mailable {
    later(email: string, after: number): boolean
}
```



<br/>


To extend an interface, you use the extends keyword with the following syntax: <br />


```
interface A {
    a(): void
}

interface B extends A {
    b(): void
}
```


<br/>
The interface B extends the interface A, which then has both methods a() and b().

Like classes, the FutureMailable interface inherits the send() and queue() methods from the Mailable interface. <br/>


```
class Mail implements FutureMailable {
    later(email: string, after: number): boolean {
        console.log(`Send email to ${email} in ${after} ms.`);
        return true;
    }
    send(email: string): boolean {
        console.log(`Sent email to ${email} after ${after} ms. `);
        return true;
    }
    queue(email: string): boolean {
        console.log(`Queue an email to ${email}.`);
        return true;
    }
}
```


<br/>

### Interfaces extending multiple interfaces


```
interface C {
    c(): void
}

interface D extends B, C {
    d(): void
}
```


<br/>
In this example, the interface D extends the interfaces B and C. So D has all the methods of B and C interfaces, which are a(), b(), and c() methods.



### Interfaces extending classes


TypeScript allows an interface to extend a class. In this case, the interface inherits the properties and methods of the class. Also, the interface can inherit the private and protected members of the class, not just the public members.

It means that when an interface extends a class with private or protected members, the interface can only be implemented by that class or subclasses of that class from which the interface extends.

By doing this, you restrict the usage of the interface to only classes or subclasses of the class from which the interface extends. If you attempt to implement the interface from a class that is not a subclass of the class that the interface inherited, you’ll get an error. For example:
<br/>


```
class Control {
    private state: boolean;
}

interface StatefulControl extends Control {
    enable(): void
}

class Button extends Control implements StatefulControl {
    enable() { }
}
class TextBox extends Control implements StatefulControl {
    enable() { }
}
class Label extends Control { }


// Error: cannot implement
class Chart implements StatefulControl {
    enable() { }

}
```


<br/>


### Summary
1. An interface can extend one or multiple existing interfaces.
2. An interface also can extend a class. If the class contains private or protected members, the interface can only be implemented by the class or subclasses of that class.

## TypeScript Intersection types
An intersection type creates a new type by combining multiple existing types. The new type has all features of the existing types. 

To combine types, you use the & operator as follows: <br/>


```
type typeAB = typeA & typeB;
```


<br/>
The typeAB will have all properties from both typeA and typeB. <br/>

Note that the union type uses the | operator that defines a variable that can hold a value of either typeA or typeB <br/>

```
let varName = typeA | typeB; // union type
```


<br/>

Suppose that you have three interfaces: BusinessPartner, Identity, and Contact.

<br/>

```
interface BusinessPartner {
    name: string;
    credit: number;
}

interface Identity {
    id: number;
    name: string;
}

interface Contact {
    email: string;
    phone: string;
}
```


<br/>

```
type Employee = Identity & Contact;
type Customer = BusinessPartner & Contact;
```


<br/>

```
type Employee = Identity & Contact;

let e: Employee = {
    id: 100,
    name: 'John Doe',
    email: 'john.doe@example.com',
    phone: '(408)-897-5684'
};
```


<br/>

```
type Customer = BusinessPartner & Contact;

let c: Customer = {
    name: 'ABC Inc.',
    credit: 1000000,
    email: 'sales@abcinc.com',
    phone: '(408)-897-5735'
};
```


<br/>


### Summary
1. An intersection type combines two or more types to create a new type that has all properties of the existing types.
2. The type order is not important when you combine types.

## TypeScript Type Guards
### typeof

```
type alphanumeric = string | number;

function add(a: alphanumeric, b: alphanumeric) {
    if (typeof a === 'number' && typeof b === 'number') {
        return a + b;
    }

    if (typeof a === 'string' && typeof b === 'string') {
        return a.concat(b);
    }

    throw new Error('Invalid arguments. Both arguments must be either numbers or strings.');
}
```


<br/>

### instanceof


```
class Customer {
    isCreditAllowed(): boolean {
        // ...
        return true;
    }
}

class Supplier {
    isInShortList(): boolean {
        // ...
        return true;
    }
}

type BusinessPartner = Customer | Supplier;

function signContract(partner: BusinessPartner) : string {
    let message: string;
    if (partner instanceof Customer) {
        message = partner.isCreditAllowed() ? 'Sign a new contract with the customer' : 'Credit issue';
    }

    if (partner instanceof Supplier) {
        message = partner.isInShortList() ? 'Sign a new contract the supplier' : 'Need to evaluate further';
    }

    return message;
}
```


<br/>

### in 
The in operator carries a safe check for the existence of a property on an object. You can also use it as a type guard. For example: <br/>


```
function signContract(partner: BusinessPartner) : string {
    let message: string;
    if ('isCreditAllowed' in partner) {
        message = partner.isCreditAllowed() ? 'Sign a new contract with the customer' : 'Credit issue';
    } else {
        // must be Supplier
        message = partner.isInShortList() ? 'Sign a new contract the supplier ' : 'Need to evaluate further';
    }
    return message;
}
```


<br/>


### Summary
1. Type guards narrow down the type of a variable within a conditional block.
2. Use the typeof and instanceof operators to implement type guards in the conditional blocks


## Type Assertions
Type assertions instruct the TypeScript compiler to treat a value as a specified type. In TypeScript, you can use the as keyword or <> operator for type assertions.

### Type assertions using the as keyword
The following selects the first input element on an HTML document using the querySelector() method: <br/>


```
let el = document.querySelector('input["type="text"]');
```


<br/>

Since the returned type of the document.querySelector() method is the Element type, the following code causes a compile-time error: <br/>


```
console.log(el.value);
```


<br/>

Error: <br/>


```
Property 'value' does not exist on type 'Element'.
```


<br/>

The reason is that the value property doesn’t exist in the Element type. It only exists on the HTMLInputElement type.

To resolve this, you can instruct the TypeScript compiler to treat the type of the el element as HTMLInputElement by using the as keyword like this: <br/>


```
const el = document.querySelector('input[type="text"]');
const input = el as HTMLInputElement;
```


<br/>


Now, the input variable has the type HTMLInputElement. So accessing its value property won’t cause any error. The following code works: 
<br/>


```
console.log(input.value);
```

<br/>
Note that the HTMLInputElement type extends the HTMLElement type that extends to the Element type. <br/>
The syntax for type assertion of a variable from typeA to typeB is as follows:

<br/>



```
let a: typeA;
let b = a as typeB;
```


<br/>


### Type assertion using the <> operator
Besides the as keyword, you can use the <> operator to perform a type assertion. For example: <br/>


```
let input = <HTMLInputElement>document.querySelector('input[type="text"]');

console.log(input.value);
```


<br/>

The syntax for type assertion using the <> operator is as follows: <br/>


```
let a: typeA;
let b = <typeB>a
```


<br/>


### Type assertion result
If a type assertion fails, different kinds of errors will occur depending on how you use type assertion and actual runtime types.


1. Compile-time errors
   When you try to perform a type assertion between incompatible types,       the TypeScript compiler may give you an error or warning. For example: <br/>


   ```
   let price = '9.99';
   let netPrice = price as number; // error
   ```


   <br/>

   In this example, we attempt to assign the number type to a string, the     TypeScript compiler issues the following compile-time error: <br/>


   ```
    Conversion of type 'string' to type 'number' may be a mistake because       neither type sufficiently overlaps with the other. If this was             intentional, convert the expression to 'unknown' first.
      ```

   <br/>

2. Runtime errors
   When you perform a type assertion of an object to a type that doesn’t       match its structure and attempt to access a property that doesn’t          exist, you’ll get a runtime error. For example: <br/>

   ```
   let el = document.querySelector('#name');
   let input = el as HTMLInputElement;
   console.log(input.value.length);
   ```

   <br/>

   In this example, if the element with id #name is not an input element,       the input.value will be undefined at runtime. Hence, accessing the       length property of the value will cause a runtime error:

   <br/>


   ```
   TypeError: Cannot read properties of undefined (reading 'length')
   ```


   <br/>

3. Unexpected behaviors
   If a type assertion is incorrect, you may not get a compile-time or          runtime error but might experience unexpected behaviors later in your       code. This can make debugging challenging because the error might not
      occur at the point of the type assertion.


### Summary
1. Type assertion allows you to assign a new type to a value.
2. Use the as keyword or <> operator to perform a type assertion.
   
   
   
   















